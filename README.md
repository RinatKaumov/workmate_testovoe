# Асинхронный сервис задач на Go

## О чём этот проект

Это моя реализация тестового задания для компании Workmate - сервис на Go, который позволяет создавать, отслеживать и удалять задачи через HTTP API.  
Задачи выполняются асинхронно и могут занимать 3–5 минут.  
Всё хранится только в памяти — никаких баз данных, очередей и сторонних сервисов.

---

## Почему я сделал именно так

**1. Всё хранится в памяти**  
Все задачи лежат в обычной Go-карте (map) внутри процесса - это по заданию.

**2. Чистая архитектура и разделение слоёв**  
Я разделил код на три слоя:
- **DAL (Data Access Layer)** — отвечает только за хранение задач (in-memory map, потокобезопасность через RWMutex).
- **Domain (Бизнес-логика)** — вся логика работы с задачами, статусы, запуск, валидация, преобразование данных для API.
- **Server (HTTP API)** — обработка HTTP-запросов, валидация пользовательского ввода, возврат ответов в JSON.

Такой подход позволяет легко менять внутренности (например, перейти на БД или добавить gRPC), не трогая остальной код.

**3. Асинхронность**  
Когда создаётся задача, она сразу возвращается клиенту, а выполнение происходит в фоне (через goroutine). Это имитирует реальную работу.

**4. Валидация и безопасность**  
Я валидирую входные данные на уровне HTTP и бизнес-логики, чтобы не пропускать мусор и потенциально опасные данные.

**5. Расширяемость**  
Архитектура позволяет легко добавлять новые типы задач, новые поля, новые способы хранения.  
Если понадобится — можно прикрутить gRPC, базу данных или что-то ещё, не переписывая бизнес-логику.

**6. Graceful shutdown**  
Сервер корректно завершает работу: при остановке он дожидается завершения текущих запросов, чтобы не потерять данные.

---

## Как запустить

1. Установите Go (1.20+).
2. Клонируйте репозиторий и перейдите в папку проекта:
   ```sh
   git clone https://github.com/RinatKaumov/workmate_testovoe.git
   cd workmate_testovoe
   ```
3. Установите зависимости:
   ```sh
   go mod tidy
   ```
4. Запустите сервер:
   ```sh
   go run main.go
   ```
   По умолчанию сервер слушает порт 8080.

---

## Примеры использования API

### Создать задачу
```http
POST /tasks
Content-Type: application/json

{
  "description": "Посчитать что-нибудь долгое"
}
```

### Получить статус задачи
```http
GET /tasks/{id}
```
Ответ:
```json
{
  "id": "...",
  "description": "Посчитать что-нибудь долгое",
  "status": "running",
  "created_at": "...",
  "started_at": "...",
  "finished_at": null,
  "result": null,
  "duration": 42
}
```

### Получить список всех задач
```http
GET /tasks
```

### Удалить задачу
```http
DELETE /tasks/{id}
```

---

## Описание полей ответа
- `id` — уникальный идентификатор задачи
- `description` — описание задачи
- `status` — статус (`pending`, `running`, `completed`)
- `created_at` — когда задача была создана
- `started_at` — когда началось выполнение (может быть null)
- `finished_at` — когда завершилось выполнение (может быть null)
- `result` — результат (может быть null)
- `duration` — продолжительность выполнения в секундах (может быть null)

> **Важно:** Поскольку данные хранятся в памяти, при перезапуске сервера все задачи будут потеряны.

---

## Корректное завершение работы
Для корректного завершения сервера используйте стандартные сигналы завершения (Ctrl+C). Сервер дождётся завершения текущих запросов.

---

## Итог

Я постарался сделать этот сервис максимально гибким, чистым и готовым к развитию, применяя все известные мне техники проектирования и разработки. Код организован так, чтобы его было удобно читать, поддерживать и масштабировать — именно так, как я вижу продуктовые решения в реальной разработке.