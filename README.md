# Асинхронный сервис задач на Go

## О чём этот проект

Это моя реализация тестового задания для компании Workmate - сервис на Go, который позволяет создавать, отслеживать и удалять задачи через HTTP API.  
Задачи выполняются асинхронно и могут занимать 3–5 минут.  
Всё хранится только в памяти — никаких баз данных, очередей и сторонних сервисов.

---

## Почему я сделал именно так

**1. Всё хранится в памяти**  
Все задачи лежат в обычной Go-карте (map) внутри процесса - это по заданию.

**2. Чистая архитектура и разделение слоёв**  
Я разделил код на три слоя:
- **DAL (Data Access Layer)** — отвечает только за хранение задач (in-memory map, потокобезопасность через RWMutex).
- **Domain (Бизнес-логика)** — вся логика работы с задачами, статусы, запуск, валидация, преобразование данных для API.
- **Server (HTTP API)** — обработка HTTP-запросов, валидация пользовательского ввода, возврат ответов в JSON.

Такой подход позволяет легко менять внутренности (например, перейти на БД или добавить gRPC), не трогая остальной код.

**3. Асинхронность**  
Когда создаётся задача, она сразу возвращается клиенту, а выполнение происходит в фоне (через goroutine). Это имитирует реальную работу.

**4. Валидация и безопасность**  
Я валидирую входные данные на уровне HTTP и бизнес-логики, чтобы не пропускать мусор и потенциально опасные данные.

**5. Расширяемость**  
Архитектура позволяет легко добавлять новые типы задач, новые поля, новые способы хранения.  
Если понадобится — можно прикрутить gRPC, базу данных или что-то ещё, не переписывая бизнес-логику.

**6. Graceful shutdown**  
Сервер корректно завершает работу: при остановке он дожидается завершения текущих запросов, чтобы не потерять данные.

---

## Как запустить

1. Установите Go (1.20+).
2. Клонируйте репозиторий и перейдите в папку проекта:
   ```sh
   git clone <repo-url>
   cd awesomeProject36
   ```
3. Запустите сервер:
   ```sh
   go run main.go
   ```
   По умолчанию сервер слушает порт 8080.

---

## Как пользоваться

### Создать задачу
```http
POST /tasks
Content-Type: application/json

{
  "description": "Посчитать что-нибудь долгое"
}
```

### Получить статус задачи
```http
GET /tasks/{id}
```
Ответ:
```json
{
  "id": "...",
  "description": "Посчитать что-нибудь долгое",
  "status": "running",
  "created_at": "...",
  "started_at": "...",
  "finished_at": null,
  "result": null,
  "error": null,
  "duration": 42
}
```

### Получить список всех задач
```http
GET /tasks
```

### Удалить задачу
```http
DELETE /tasks/{id}
```

---

## Что возвращается в ответе

- `id` — уникальный идентификатор задачи
- `description` — описание задачи
- `status` — статус (`pending`, `running`, `completed`, `failed`)
- `created_at` — когда задача была создана
- `started_at` — когда началось выполнение (может быть null)
- `finished_at` — когда завершилось выполнение (может быть null)
- `result` — результат (может быть null)
- `error` — ошибка (может быть null)
- `duration` — продолжительность выполнения в секундах (может быть null)

---

## Почему этот сервис легко развивать

- **Можно добавить новые поля или типы задач** — не нужно переписывать весь код.
- **Можно заменить in-memory на БД** — просто реализовать новый репозиторий.
- **Можно добавить gRPC или другой интерфейс** — бизнес-логика не изменится.
- **Код легко читать, тестировать и поддерживать** — всё разбито по слоям, нет «спагетти».

---

## Итог

Я постарался сделать сервис гибким и готовым к развитию, следуя заданию и используя все техники которые мне известны, чтобы результат был максимально похож на продуктовые решения.  
